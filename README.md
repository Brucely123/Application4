# Application4
Analysis Questions
Engineering Analysis Questions (in your README)
Signal Discipline: How does the binary semaphore synchronize the button task with the system? What happens if the button is pressed multiple times quickly? How might this differ if youâ€™d used a counting semaphore instead?
**Binaries serve as signals to synchronize button tasks with the rest of the system: when a button is pressed and debounced, the ISR or task gives a semaphore, and the event handler task takes it. If a button is pressed multiple times quickly, only the first press will capture the semaphore if the semaphore has not yet been taken. Subsequent presses will be ignored since a binary semaphore can only hold a value of 0 or 1. A counting semaphore would count every press, even if they occurred rapidly, allowing the system to respond to each one in turn, which may or may not be desirable, depending on the application.**

Event Flood Handling: When you adjust the potentiometer rapidly above/below threshold, what behavior do you observe with the red LED and console prints? How does the counting semaphore handle multiple signals? What would break if you swapped it for a binary semaphore?
**Potentiometers are rapidly adjusted across the threshold, causing the red LED to blink repeatedly, and numerous "Radiation Threshold Exceeded" messages to appear on the console. With the counting semaphore used for sensor alerts, multiple signals can be accumulated (up to the defined MAX_COUNT_SEM), ensuring that no threshold event is missed. Instead of a binary semaphore, only one signal would be recorded until taken, resulting in multiple threshold crossings being lost. As a result, events would be under-reported and alert behavior would be less responsive, especially during times of rapid threshold fluctuations.**
Protecting Shared Output: Describe a moment where removing the mutex caused incorrect console behavior or other issues. Why do mutexes matter for protecting output? What real-world failure could occur if logs were interleaved or shared state was modified concurrently?

**In the case of sensor and button tasks triggering simultaneously, the console output became interleaved when the print_mutex was removed from around the printf statements. There were several broken messages, overlapped messages, or messages that were partially missing. The problem was caused by printf not being thread-safe, and multiple tasks were attempting to access it simultaneously. A mutex prevents this by restricting access to a shared resource (in this case, UART output) to one task at a time. This could conceal system faults or confuse diagnostics during mission-critical operations in a real-world system due to race conditions.**
Scheduling and Preemption: Did task priorities influence system responsiveness as expected? Give one example where a high-priority task preempted a lower one. What happened to the heartbeat during busy periods?
**It was expected that task priorities would impact responsiveness. A button task (priority 3) that detects a press causes an event handler task to run almost immediately, preempting both the sensor and heartbeat tasks. A pause in the heartbeat LED (green) was occasionally observed during busy periods when multiple alerts or button presses were triggered, indicating a delay in lower-priority tasks during high-priority tasks. Clearly, this is a case of preemptive scheduling, in which task priorities determine who gets CPU time.**

Timing and Responsiveness: The code provided uses `vTaskDelay` rather than `vTaskDelayUntil`. How did delays impact system responsiveness and behavior? Does the your polling rate affect event detection? Would you consider changing any of the `vTaskDelay` rather than `vTaskDelayUntil` - why or why not? Adjust your code accordingly.
**When using vTaskDelay, each task sleeps for a given period of time, but it doesn't account for how long the task took to execute before delaying, which can result in timing drift over time. Responding to tasks like sensor polling, where consistent sampling intervals are important, can be affected slightly by this. The vTaskDelayUntil function would be better in control systems since it delays until a fixed time interval based on the last wake time is reached, preventing drift. It might be worth considering changing the heartbeat and sensor tasks in this system to use vTaskDelayUntil to maintain more consistent timing and periodicity.**

Theme Integration: Connect your implementation to your chosen theme. What does each task/LED/semaphore represent in that real-world system? How might synchronization be life-critical in your domain?
**The space systems theme includes a wide range of components that are crucial to the monitoring and control of spacecraft in real time. A potentiometer simulates an analog sensor monitoring radiation levels in space. Just as a real satellite flags dangerous cosmic radiation spikes, this task checks for overexposure events and signals the event handler. Using the button task, mission operators can toggle system modes or trigger manual responses. These external inputs are alerted via a binary semaphore. Upon a sensor alert, the red LED illuminates, simulating a radiation warning system; upon a button press, the red LED illuminates, indicating a manual mode change. Keeping the scheduler running is indicated by the green LED, the heartbeat indicator. Regular blinks indicate that the system is alive and not being blocked or starved. This domain relies on synchronization because improper handling of alerts or missed sensor readings could mean crew safety and equipment integrity are at risk. A poorly coordinated task or race conditions can lead to misinterpretation or loss of ground control commands. The use of semaphores and mutexes ensures logical correctness and assures system reliability and safety.**

[Bonus] Induced Failure: Can you create a situation where the system starves one or more tasks? (E.g., block the heartbeat for more than 3 seconds, or drop button events.) What caused it? Leave your code commented in the project with an explanation.
**I intentionally inserted a four second blocking delay inside the event_handler_task in order to starve the heartbeat task. I added a vTaskDelay(pdMS_TO_TICKS(4000)) call after the red LED was triggered by the sensor semaphore. With the event_handler_task having a higher priority than the heartbeat_task, this lengthy delay effectively prevents the heartbeat task from running, resulting in a green LED not blinking for over 3 seconds. As a result of this induced failure, long-running high-priority tasks are starved of resources in a preemptive RTOS, emphasizing the need to avoid lengthy blocking operations. There is a clear comment explaining this behavior.**




